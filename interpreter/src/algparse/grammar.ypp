%{
#include "alglex.h"

  
%}

%code requires {
    void algerror(tarski::LexContext *LC, tarski::TarskiRef &result, char const *msg);
    int algparse(tarski::LexContext*, tarski::TarskiRef&);
 }

//%define api.namespace {tarski}

%define api.pure
%parse-param { tarski::LexContext *LC }
%parse-param { tarski::TarskiRef &result }
%lex-param   { tarski::LexContext *LC }
%define api.prefix {alg}

/**** Define terminals & non-terminals & bison directives ****/
%union algValue {
  tarski::TokenRef*     tokPtr;
  tarski::AlgebraicRef* algPtr;
  tarski::FormulaRef*   frmPtr;
}

%token <tokPtr> PLUS MINUS MULT DIV EXP VAR NUM LP RP RELOP TCONST FCONST LB RB AND OR LIMPLR NEG ROOT LEXERR QF COMMA INTERP PERCENT

%type <algPtr> E T P Pb B

%type <frmPtr> O F C N A Q

%destructor { /*delete $$;*/ } PLUS MINUS  MULT DIV EXP VAR NUM LP RP RELOP TCONST FCONST LB RB AND OR LIMPLR NEG ROOT LEXERR INTERP PERCENT
%destructor { /*delete $$;*/ } E T P Pb B
%destructor { /*delete $$;*/ } O F C N A Q

%nonassoc RB
%nonassoc RP

%%

/** ALGEBRAIC OBJECT ************************************/
O : LB E RB { result = *((tarski::TarskiRef*)$2);  $$ = 0; delete $1; delete $2; delete $3; YYACCEPT; }
  | LB F RB { result = *((tarski::TarskiRef*)$2);  $$ = 0; delete $1; delete $2; delete $3; YYACCEPT; }
  ;

/** FORMULAS ********************************************/
F : F OR C   { $$ = tarski::newOr($1,$3);             delete $1; delete $2; delete $3; }
  | F LIMPLR C { tarski::FormulaRef* p = newNot($1); $$ = newOr(p,$3);   delete $1; delete $2; delete $3; delete p; }
  | C { $$ = tarski::copy($1);                        delete $1; }
  ;
C : C AND N { $$ = tarski::newAnd($1,$3);             delete $1; delete $2; delete $3; }
  | N { $$ = tarski::copy($1);                        delete $1; }
  ;
N : NEG N { $$ = tarski::newNot($2);                  delete $1; delete $2; }
  | A { $$ = tarski::copy($1);                        delete $1; }
  ;
A : Q LB F RB { $$ = tarski::addFormulaToQuantifier($1,$3); delete $1; delete $2; delete $3; delete $4; }
  | E RELOP ROOT P E { $$ = tarski::newExtTarskiAtom($1,$2,$4,$5); delete $1; delete $2; delete $3; delete $4; delete $5; }
  | E RELOP E { $$ = tarski::newTarskiAtom($1,$2,$3); delete $1; delete $2; delete $3; }
  | LB F RB { $$ = tarski::copy($2);                  delete $1; delete $2; delete $3; }
  | LP F RP { $$ = tarski::copy($2);                  delete $1; delete $2; delete $3; }
  | TCONST { $$ = tarski::newTrue();                  delete $1; }
  | FCONST { $$ = tarski::newFalse();                 delete $1; }
  | INTERP VAR { $$ = tarski::newInterpVar($2);       delete $1;    delete $2; }
  | INTERP PERCENT { $$ = tarski::newInterpVar($2);       delete $1;    delete $2; }
/*  | VAR */
  ;

/** QUANTIFIER BLOCK ************************************/
Q : Q COMMA VAR { $$ = tarski::addVarToQuantifier($1,$3); delete $1; delete $2; delete $3; }
  | QF VAR { $$ = tarski::newQuantifierBlock($1,$2);      delete $1; delete $2; }

/** EXPRESSIONS *****************************************/
E : E PLUS T  { $$ = tarski::newAdd($1,$3);           delete $1; delete $2; delete $3; }
  | E MINUS T { $$ = tarski::newSbt($1,$3);           delete $1; delete $2; delete $3; }
  | T { $$ = tarski::copy($1);                        delete $1; } 
  ;
T : T Pb { $$ = tarski::newMlt($1,$2);                delete $1; delete $2; }
  | T MULT P { $$ = tarski::newMlt($1,$3);            delete $1; delete $2; delete $3; }
  | T DIV P  { $$ = tarski::newDiv($1,$3);            delete $1; delete $2; delete $3; }
  | P {  $$ = tarski::copy($1);                       delete $1; }
  ;
P : MINUS P { $$ = tarski::newOpo($2);                delete $1; delete $2; }
  | B EXP P { $$ = tarski::newExp($1,$3);             delete $1; delete $2; delete $3; }
  | B { $$ = tarski::copy($1);                        delete $1;  }
  ;
Pb: B EXP P { $$ = tarski::newExp($1,$3);             delete $1; delete $2; delete $3; }
  | B { $$ = tarski::copy($1);                        delete $1; }
  ;
B : VAR { $$ = tarski::newVar($1);                    delete $1;  }
  | NUM { $$ = tarski::newNum($1);                    delete $1;  }
  | LP E RP {  $$ = tarski::copy($2);                 delete $1; delete $2; delete $3; }
  ;
%%

  void algerror(tarski::LexContext *LC, tarski::TarskiRef &result, char const *msg)
  {
  }

